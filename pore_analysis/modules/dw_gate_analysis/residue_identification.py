# filename: pore_analysis/modules/dw_gate_analysis/residue_identification.py
"""
Functions for identifying DW-Gate residues (Asp/Glu and Trp)
relative to the selectivity filter motif.
"""

import logging
from dataclasses import dataclass
from typing import Optional, Dict, List

import MDAnalysis as mda

# --- Dependency Note ---
# This module relies on filter_res_map being provided, which is typically
# generated by the ion_analysis module and retrieved from the database
# by the dw_gate_analysis/computation.py module.

logger = logging.getLogger(__name__)

@dataclass
class GateResidues:
    """Holds the identified Asp/Glu and Trp residue objects for a single chain."""
    chain_id: str
    asp_glu_res: mda.core.groups.Residue
    trp_res: mda.core.groups.Residue

def select_dw_residues(
    universe: mda.Universe,
    chain_ids: List[str],
    filter_res_map: Dict[str, List[int]]
) -> Dict[str, GateResidues]:
    """
    Selects the D/E and W residues involved in the gate for each specified chain
    by calling find_gate_residues_for_chain for each chain.

    Args:
        universe: MDAnalysis Universe.
        chain_ids: List of segment/chain IDs to search within.
        filter_res_map: Dictionary mapping chain ID to list of filter residue IDs.

    Returns:
        Dictionary mapping chain ID to the found GateResidues object.
        Returns an empty dict if no valid residues are found or errors occur.
    """
    gate_residues: Dict[str, GateResidues] = {}
    logger.info(f"Attempting to identify DW-gate residues relative to filter for chains: {chain_ids}")

    if not filter_res_map:
        logger.error("Filter residue map is empty. Cannot identify relative DW-gate residues.")
        return {}

    for segid in chain_ids:
        # Check if this segid exists in the filter map before proceeding
        if segid not in filter_res_map:
            logger.warning(f"Skipping DW gate search for segid {segid}: Not found in filter_res_map.")
            continue

        try:
            # Call find_gate_residues_for_chain with the correct 3 arguments
            gate = find_gate_residues_for_chain(
                u=universe, # Use keyword arg for clarity
                segid=segid,
                filter_res_map=filter_res_map
            )
            # No need to check 'if gate:' because the function raises ValueError on failure
            gate_residues[segid] = gate
            logger.debug(f"Found gate residues for chain {segid}: {gate}")
        except ValueError as e:
            # Catch specific errors from find_gate_residues_for_chain
            logger.warning(f"Could not identify DW gate for chain {segid}: {e}")
        except Exception as e:
            # Catch unexpected errors
            logger.error(f"Unexpected error finding gate residues for chain {segid}: {e}", exc_info=True)

    if not gate_residues:
        logger.error("Failed to identify any valid DW-gate residue pairs for the specified chains.")
    else:
        logger.info(f"Successfully identified gate residues for chains: {list(gate_residues.keys())}")
    return gate_residues


def find_gate_residues_for_chain(u: mda.Universe, segid: str, filter_res_map: dict) -> GateResidues:
    """
    Identifies the Asp/Glu and Trp residues forming the DW-gate for a specific chain.

    Searches relative to the G1 and G2 residues of the selectivity filter (TVGYG).
    - Asp/Glu: First D/E residue with resid between G2+1 and G2+6 (inclusive).
    - Trp: W residue with the lowest resid between G1-16 and G1-6 (inclusive).

    Args:
        u (mda.Universe): The MDAnalysis Universe.
        segid (str): The segment ID of the chain to analyze.
        filter_res_map (dict): Dictionary mapping segid to list of filter residue IDs
                               (output from find_filter_residues).

    Returns:
        GateResidues: A dataclass containing the chain_id and the identified
                      Asp/Glu and Trp MDAnalysis.Residue objects.

    Raises:
        ValueError: If filter residues are not found for the chain, if D/E or W
                    residues are not found in the specified ranges, or if the
                    identified D/E and W residues do not meet the spacing validation.
    """
    logger.debug(f"Attempting to find DW gate residues for segid {segid}...")

    filter_resids = filter_res_map.get(segid)
    if not filter_resids or len(filter_resids) != 5:
        raise ValueError(f"Valid 5-residue filter not found for segid {segid} in filter_res_map.")

    # Get G1 (index 2) and G2 (index 4) resids
    g1_resid = filter_resids[2]
    g2_resid = filter_resids[4]
    logger.debug(f"Segid {segid}: G1={g1_resid}, G2={g2_resid}")

    # Select the entire chain's residues once
    try:
        chain_residues = u.select_atoms(f"segid {segid}").residues
        if not chain_residues:
             raise ValueError(f"Segid {segid} selected 0 residues.")
    except Exception as e:
        raise ValueError(f"Failed to select residues for segid {segid}: {e}")

    found_asp_glu: Optional[mda.core.groups.Residue] = None
    found_trp: Optional[mda.core.groups.Residue] = None

    # --- Find Asp/Glu (D/E) --- Residue with LOWEST resid in range (g2+1, g2+6]
    min_asp_glu_resid = float('inf')
    asp_glu_search_start = g2_resid + 1
    asp_glu_search_end = g2_resid + 6
    logger.debug(f"Searching for D/E in resid range ({asp_glu_search_start}, {asp_glu_search_end}]")
    for res in chain_residues:
        if asp_glu_search_start <= res.resid <= asp_glu_search_end:
            if res.resname in ("ASP", "GLU"):
                logger.debug(f"  Found potential D/E: {res.resname}{res.resid}")
                if res.resid < min_asp_glu_resid:
                    min_asp_glu_resid = res.resid
                    found_asp_glu = res

    if found_asp_glu is None:
        raise ValueError(f"No ASP or GLU found C-terminal to filter (resids {asp_glu_search_start}-{asp_glu_search_end}) in segid {segid}.")
    logger.debug(f"Selected D/E for segid {segid}: {found_asp_glu.resname}{found_asp_glu.resid}")

    # --- Find Trp (W) --- Residue with LOWEST resid in range [g1-16, g1-6]
    min_trp_resid = float('inf')
    trp_search_start = g1_resid - 16
    trp_search_end = g1_resid - 6
    logger.debug(f"Searching for W in resid range [{trp_search_start}, {trp_search_end}]")
    for res in chain_residues:
        if trp_search_start <= res.resid <= trp_search_end:
            if res.resname == "TRP":
                logger.debug(f"  Found potential W: {res.resname}{res.resid}")
                if res.resid < min_trp_resid:
                    min_trp_resid = res.resid
                    found_trp = res

    if found_trp is None:
        raise ValueError(f"No TRP found N-terminal to filter (resids {trp_search_start}-{trp_search_end}) in segid {segid}.")
    logger.debug(f"Selected W for segid {segid}: {found_trp.resname}{found_trp.resid}")

    # --- Validate Spacing --- (10 <= asp_idx â€“ trp_idx <= 25)
    spacing = found_asp_glu.resid - found_trp.resid
    logger.debug(f"Residue spacing D/E ({found_asp_glu.resid}) - W ({found_trp.resid}) = {spacing}")
    if not (10 <= spacing <= 25):
        raise ValueError(f"Invalid DW gate spacing ({spacing}) for segid {segid}. Expected 10-25. (D/E: {found_asp_glu.resid}, W: {found_trp.resid})")

    logger.info(f"Successfully identified DW gate for segid {segid}: D/E={found_asp_glu.resname}{found_asp_glu.resid}, W={found_trp.resname}{found_trp.resid}")
    return GateResidues(chain_id=segid, asp_glu_res=found_asp_glu, trp_res=found_trp)
