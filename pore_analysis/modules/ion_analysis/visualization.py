# Proposed content for: pore_analysis/modules/ion_analysis/visualization.py
# filename: pore_analysis/modules/ion_analysis/visualization.py
"""
Ion Analysis: Plot generation functions using HMM results.
Reads data from files generated by the computation steps.
"""
import os
import logging
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import to_rgb, rgb_to_hsv, hsv_to_rgb
from matplotlib.lines import Line2D # For custom legends
from matplotlib.patches import Patch # For custom legends
import sqlite3
from typing import Dict, Optional, List, Tuple, Any
import time
from collections import defaultdict

# Import from core modules
try:
    from pore_analysis.core.plotting_style import STYLE, setup_style
    from pore_analysis.core.database import register_module, update_module_status, get_product_path, register_product, get_all_metrics # Added get_all_metrics
    from pore_analysis.core.config import (
         VIZ_HIGH_OCC_THRESHOLD_PCT, VIZ_MEDIUM_OCC_THRESHOLD_PCT # Import viz thresholds
         )
except ImportError as e:
    print(f"Error importing dependency modules in ion_analysis/visualization.py: {e}")
    raise

logger = logging.getLogger(__name__)

# Apply standard plotting style
setup_style()

# --- Plotting Helper: Pastel Colors ---
def _make_pastel(color, factor=0.5, light_boost=0.15):
    """Create a pastel version of a color."""
    try:
        rgb = to_rgb(color)
        h, s, v = rgb_to_hsv(rgb)
        pastel_s = max(0, s * (1.0 - factor))
        pastel_v = min(1, v + light_boost)
        return hsv_to_rgb((h, pastel_s, pastel_v))
    except Exception as e:
        logger.warning(f"Could not create pastel color for {color}: {e}")
        return color # Return original on error

# --- Plotting Function: Binding Site Schematic ---
def _plot_binding_site_schematic(
    sites_file_path: str, # Path to OPTIMIZED sites file
    output_dir: str,
    run_dir: str,
    db_conn: sqlite3.Connection,
    module_name: str
) -> Optional[str]:
    """Plots binding site schematic from the OPTIMIZED definition file."""
    if not os.path.exists(sites_file_path):
        logger.error(f"Binding site definition file not found: {sites_file_path}")
        return None

    sites_g1_centric = {}
    g1_ca_z_ref_str = "N/A"
    is_optimized = False
    try:
        with open(sites_file_path, 'r') as f:
            lines = f.readlines()
            for line in lines:
                 # Check for new header indicating optimized sites
                 if 'OPTIMIZED K+ channel' in line:
                      is_optimized = True
                 # Extract G1 ref Z (handle potential variations in comment format)
                 if 'Absolute Z-coordinate of G1 C-alpha reference plane:' in line:
                      g1_ca_z_ref_str = line.split(':')[-1].strip().split(' ')[0] # Extract number robustly
                 elif 'G1_C_alpha_reference_position_absolute_Z:' in line: # Fallback to old format
                      g1_ca_z_ref_str = line.split(':')[-1].strip()

                 # Parse site: position lines
                 if ':' in line and not line.strip().startswith('#'):
                    parts = line.strip().split(':')
                    site = parts[0].strip()
                    try: sites_g1_centric[site] = float(parts[1].strip())
                    except ValueError: continue
        if not sites_g1_centric: raise ValueError("No site positions parsed.")
    except Exception as e:
        logger.error(f"Failed to parse binding site file {sites_file_path}: {e}")
        return None

    plot_title_suffix = "(Optimized)" if is_optimized else "(Default)"
    logger.debug(f"Plotting binding site schematic for {len(sites_g1_centric)} sites {plot_title_suffix}.")

    fig, ax = plt.subplots(figsize=(6, 8))
    site_colors = STYLE['state_colors'] # Use existing color definitions if suitable
    site_display_colors = { 'S0': '#FF6347', 'S1': '#4169E1', 'S2': '#2E8B57',
                            'S3': '#BA55D3', 'S4': '#CD853F', 'Cavity': '#708090' }

    channel_width = 0.4
    channel_left = 0.1
    site_values = list(sites_g1_centric.values())
    y_min, y_max = min(site_values) - 2.0, max(site_values) + 2.0

    ax.plot([channel_left, channel_left], [y_min, y_max], color=STYLE['threshold_style']['color'], linestyle='-', linewidth=1.5, alpha=0.7)
    ax.plot([channel_left + channel_width, channel_left + channel_width], [y_min, y_max], color=STYLE['threshold_style']['color'], linestyle='-', linewidth=1.5, alpha=0.7)

    # Filter rectangle (using optimized/loaded sites)
    try:
        # Ensure S0 and S4 exist before trying to access them
        if 'S0' in sites_g1_centric and 'S4' in sites_g1_centric:
             filter_top = sites_g1_centric['S0']
             filter_bottom = sites_g1_centric['S4']
             rect = plt.Rectangle((channel_left, filter_bottom), channel_width, filter_top - filter_bottom,
                                   color=STYLE['grid']['color'], alpha=0.2, zorder=0)
             ax.add_patch(rect)
        else:
             logger.warning("S0 or S4 missing from site definitions, cannot draw filter rectangle.")
    except KeyError: pass # Should be caught by the 'in' check above

    ax.axhline(y=0, color=STYLE['threshold_style']['color'], linestyle=':', alpha=0.9, linewidth=1.5, zorder=2)
    ax.text(channel_left + channel_width + 0.05, 0, "G1 Cα (Z=0)", va='center', ha='left',
            fontsize=STYLE['font_sizes']['annotation'], fontweight='bold', color=STYLE['threshold_style']['color'], zorder=3)

    for site, z_pos_rel in sorted(sites_g1_centric.items(), key=lambda item: item[1], reverse=True):
        color = site_display_colors.get(site, 'grey')
        ax.axhline(y=z_pos_rel, color=color, linestyle='--', alpha=0.8, linewidth=1.5, zorder=2)
        ax.text(channel_left + channel_width + 0.05, z_pos_rel, f"{site}: {z_pos_rel:.2f} Å",
                va='center', ha='left', fontsize=STYLE['font_sizes']['annotation'], color=color, zorder=3)

    ax.text(channel_left + channel_width / 2, y_max + 0.5, "Extracellular", ha='center', va='bottom',
            fontsize=STYLE['font_sizes']['tick_label'], color='blue', zorder=1)
    ax.text(channel_left + channel_width / 2, y_min - 0.5, "Intracellular", ha='center', va='top',
            fontsize=STYLE['font_sizes']['tick_label'], color='red', zorder=1)

    ax.set_xlim(0, channel_left + channel_width + 0.8) # Increased xlim slightly for labels
    ax.set_ylim(y_min, y_max)
    ax.set_ylabel('Z-Position relative to G1 Cα (Å)')
    ax.get_xaxis().set_visible(False)
    ax.grid(axis='y', linestyle=STYLE['grid']['linestyle'], alpha=STYLE['grid']['alpha'], color=STYLE['grid']['color'], zorder=0)
    # No Python title

    plt.tight_layout()
    plot_filename = 'binding_sites_g1_centric_visualization.png' # Keep filename consistent
    figure_path = os.path.join(output_dir, plot_filename)
    rel_path = os.path.relpath(figure_path, run_dir)
    try:
        fig.savefig(figure_path, dpi=150)
        plt.close(fig)
        logger.info(f"Binding site visualization saved to {figure_path}")
        register_product(db_conn, module_name, "png", "plot", rel_path,
                         subcategory="binding_sites_g1_centric_visualization", # FIXED: Match the subcategory expected in the template
                         description=f"Schematic of {plot_title_suffix} binding site positions relative to G1 C-alpha (Ref Z={g1_ca_z_ref_str} Å).")
        return rel_path
    except Exception as e:
        logger.error(f"Failed to save/register binding site visualization: {e}")
        if plt.fignum_exists(fig.number): plt.close(fig)
        return None


# --- Plotting Function: Ion Positions & Density (Largely unchanged) ---
def _plot_ion_positions_density(
    position_file_path: str, # G1-centric positions
    sites_file_path: Optional[str], # Optimized sites
    output_dir: str,
    run_dir: str,
    db_conn: sqlite3.Connection,
    module_name: str
) -> Optional[str]:
    """Plots ion Z-positions and density distribution from CSV."""
    if not os.path.exists(position_file_path):
        logger.error(f"Ion position file not found: {position_file_path}")
        return None

    try:
        df = pd.read_csv(position_file_path)
        if 'Time (ns)' not in df.columns: raise ValueError("Missing 'Time (ns)' column.")
        time_points = df['Time (ns)'].values
        ion_cols = [col for col in df.columns if col.startswith('Ion_') and col.endswith('_Z_G1Centric')]
        if not ion_cols: logger.warning("No 'Ion_..._Z_G1Centric' columns found in position file."); return None # Changed to warning

        ions_z_g1 = {int(col.split('_')[1]): df[col].values for col in ion_cols}
        ion_indices = sorted(list(ions_z_g1.keys()))
        if not ion_indices: logger.warning("No ion data extracted from position file."); return None # Add check

    except Exception as e:
        logger.error(f"Failed to load or parse ion position data from {position_file_path}: {e}")
        return None

    filter_sites = {}
    if sites_file_path and os.path.exists(sites_file_path):
        try:
            with open(sites_file_path, 'r') as f:
                lines = f.readlines()
                for line in lines:
                    if ':' in line and not line.startswith('#'):
                        parts = line.strip().split(':')
                        try: filter_sites[parts[0].strip()] = float(parts[1].strip())
                        except (ValueError, IndexError): continue
        except Exception as e: logger.warning(f"Could not load site positions from {sites_file_path} for density plot: {e}")
    if not filter_sites: logger.warning("No site positions loaded for density plot background lines.")


    logger.debug(f"Plotting ion positions for {len(ion_indices)} ions.")
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 8), sharey=True, gridspec_kw={'width_ratios': [3, 1]})
    site_display_colors = { 'S0': '#FF6347', 'S1': '#4169E1', 'S2': '#2E8B57',
                           'S3': '#BA55D3', 'S4': '#CD853F', 'Cavity': '#708090' }
    plot_colors = sns.color_palette("husl", len(ion_indices))

    # Left subplot: Time series
    for i, ion_idx in enumerate(ion_indices):
        ion_data = ions_z_g1.get(ion_idx, np.array([])) # Use .get for safety
        mask = np.isfinite(ion_data)
        if np.any(mask):
            t_points_masked = time_points[mask]
            z_values_masked = ion_data[mask]
            # Ensure lengths match after masking
            if len(t_points_masked) == len(z_values_masked):
                 ax1.plot(t_points_masked, z_values_masked, color=plot_colors[i], linewidth=1.0, alpha=0.8, label=f'Ion {ion_idx}' if len(ion_indices)<=10 else None)
            else:
                 logger.warning(f"Length mismatch after masking for Ion {ion_idx} in time series plot.")


    # Add site lines
    label_x_pos = time_points[0] - (time_points[-1] - time_points[0]) * 0.01 # Position labels to the left
    for site, z_pos_rel in filter_sites.items():
        color = site_display_colors.get(site, 'grey')
        ax1.axhline(y=z_pos_rel, color=color, linestyle='--', alpha=0.7, linewidth=1.2, zorder=1)
        ax1.text(label_x_pos, z_pos_rel, site, va='center', ha='right', fontsize=STYLE['font_sizes']['annotation'] * 0.9, color=color, zorder=2,
                 bbox=dict(facecolor='white', alpha=0.5, pad=0.1, edgecolor='none'))
    ax1.axhline(y=0, color=STYLE['threshold_style']['color'], linestyle=':', alpha=0.9, linewidth=1.2, zorder=1) # G1 Ref line
    ax1.set_xlabel('Time (ns)')
    ax1.set_ylabel('Z-Position relative to G1 Cα (Å)')
    ax1.grid(axis='y', linestyle=STYLE['grid']['linestyle'], alpha=STYLE['grid']['alpha'], color=STYLE['grid']['color'], zorder=0)
    if len(ion_indices) <= 10: ax1.legend(fontsize='x-small')

    # Right subplot: Density
    all_z_g1_flat = np.concatenate([arr[np.isfinite(arr)] for arr in ions_z_g1.values() if np.any(np.isfinite(arr))])
    if len(all_z_g1_flat) > 10:
         sns.kdeplot(y=all_z_g1_flat, ax=ax2, color='black', fill=True, alpha=0.2, linewidth=1.5)
         ax2.set_xlabel('Density')
    else: ax2.set_xlabel(''); ax2.text(0.5, 0.5, 'No data for Density', ha='center', va='center', transform=ax2.transAxes)

    for site, z_pos_rel in filter_sites.items(): # Add site lines without labels
         ax2.axhline(y=z_pos_rel, color=site_display_colors.get(site, 'grey'), linestyle='--', alpha=0.7, linewidth=1.2, zorder=1)
    ax2.axhline(y=0, color=STYLE['threshold_style']['color'], linestyle=':', alpha=0.9, linewidth=1.2, zorder=1)
    ax2.grid(axis='y', linestyle=STYLE['grid']['linestyle'], alpha=STYLE['grid']['alpha'], color=STYLE['grid']['color'], zorder=0)

    # Set shared Y limits
    all_finite_z = all_z_g1_flat[np.isfinite(all_z_g1_flat)]
    if filter_sites:
        site_values = list(filter_sites.values())
        y_min_sites, y_max_sites = min(site_values), max(site_values)
        # Include data range if it extends beyond sites
        if len(all_finite_z) > 0:
             y_min_data, y_max_data = np.min(all_finite_z), np.max(all_finite_z)
             y_min = min(y_min_sites, y_min_data) - 3.0
             y_max = max(y_max_sites, y_max_data) + 3.0
        else:
             y_min, y_max = y_min_sites - 3.0, y_max_sites + 3.0
    elif len(all_finite_z) > 0: y_min, y_max = np.min(all_finite_z) - 3.0, np.max(all_finite_z) + 3.0
    else: y_min, y_max = -15, 15 # Fallback
    ax1.set_ylim(y_min, y_max)

    # No title: plt.suptitle(...)
    plt.tight_layout(pad=0.5) # Reduce padding slightly
    plot_filename = 'K_Ion_Combined_Plot.png'
    figure_path = os.path.join(output_dir, plot_filename)
    rel_path = os.path.relpath(figure_path, run_dir)
    try:
        fig.savefig(figure_path, dpi=150)
        plt.close(fig)
        logger.info(f"Saved combined ion plot to {figure_path}")
        register_product(db_conn, module_name, "png", "plot", rel_path,
                         subcategory="combined_plot", # Keep consistent subcategory
                         description="K+ ion Z-position time series (left) and density distribution (right).")
        return rel_path
    except Exception as e:
        logger.error(f"Failed to save/register combined ion plot: {e}")
        if plt.fignum_exists(fig.number): plt.close(fig)
        return None

# --- Plotting Function: Occupancy Heatmap & Bar Chart ---
def _plot_occupancy_maps(
    occupancy_file_path: str, # ion_occupancy_per_frame.csv
    output_dir: str,
    run_dir: str,
    db_conn: sqlite3.Connection,
    module_name: str
) -> Tuple[Optional[str], Optional[str]]:
    """Plots occupancy heatmap and average occupancy bar chart from CSV."""
    # Assuming STYLE is imported/applied elsewhere (e.g., via setup_style in the main visualization function)
    # from pore_analysis.core.plotting_style import STYLE # Import if needed directly
    paths = {'heatmap': None, 'barchart': None}
    if not os.path.exists(occupancy_file_path):
        logger.error(f"Occupancy data file not found: {occupancy_file_path}")
        return None, None

    try:
        df = pd.read_csv(occupancy_file_path)
        if 'Time (ns)' not in df.columns: raise ValueError("Missing 'Time (ns)' column.")
        time_points = df['Time (ns)'].values
        site_cols = [col for col in df.columns if col != 'Time (ns)']
        if not site_cols: raise ValueError("No site occupancy columns found.")

        # Try to maintain standard order if possible
        standard_sites = ['S0', 'S1', 'S2', 'S3', 'S4', 'Cavity']
        site_names_ordered = [s for s in standard_sites if s in site_cols] # Keep only existing standard sites in order
        other_sites = [s for s in site_cols if s not in standard_sites] # Add any non-standard sites found
        site_names_ordered.extend(sorted(other_sites)) # Add others alphabetically

        occupancy = df[site_names_ordered].values
        if occupancy.size == 0: raise ValueError("Occupancy data is empty after selecting columns.")

    except Exception as e:
        logger.error(f"Failed to load or parse occupancy data from {occupancy_file_path}: {e}")
        return None, None

    # --- Heatmap ---
    try:
        fig_h, ax_h = plt.subplots(figsize=(12, 6))
        max_occ = np.max(occupancy) if occupancy.size > 0 else 1
        cmap = plt.cm.get_cmap("viridis", int(max_occ) + 1) # Ensure integer ticks

        im = ax_h.imshow(occupancy.T, aspect='auto', cmap=cmap, interpolation='nearest', origin='lower', # Keep origin='lower'
                       extent=[time_points[0], time_points[-1], -0.5, len(site_names_ordered)-0.5], # Adjust extent for lower origin
                       vmin=-0.5, vmax=max_occ + 0.5)
        cbar = plt.colorbar(im, ax=ax_h, ticks=np.arange(int(max_occ) + 1))
        # cbar.set_label('Number of K+ Ions') # Fontsize set by rcParams
        cbar.ax.tick_params(labelsize=10) # Example: Explicitly set cbar tick label size if needed
        cbar.set_label('Number of K+ Ions', size=12) # Example: Explicitly set cbar label size


        ax_h.set_yticks(np.arange(len(site_names_ordered))) # Ticks at integer positions
        ax_h.set_yticklabels(site_names_ordered) # Labels match ticks
        ax_h.set_xlabel('Time (ns)')
        ax_h.set_ylabel('Binding Site')

        # --- ADD THIS LINE TO INVERT THE Y-AXIS ---
        ax_h.invert_yaxis()
        # -------------------------------------------

        # No title
        plt.tight_layout()
        heatmap_filename = 'K_Ion_Occupancy_Heatmap.png'
        heatmap_path = os.path.join(output_dir, heatmap_filename)
        rel_path_h = os.path.relpath(heatmap_path, run_dir)
        fig_h.savefig(heatmap_path, dpi=150)
        plt.close(fig_h)
        logger.info(f"Saved occupancy heatmap to {heatmap_path}")
        # --- REGISTER PRODUCT (Error Handling Added) ---
        try:
            register_product(db_conn, module_name, "png", "plot", rel_path_h,
                         subcategory="occupancy_heatmap", # Keep consistent subcategory
                         description="Heatmap of K+ ion occupancy per site over time.")
            paths['heatmap'] = rel_path_h
        except Exception as e_reg:
             logger.error(f"Failed to register occupancy heatmap product: {e_reg}")
             # path['heatmap'] remains None

    except Exception as e:
         logger.error(f"Failed to generate occupancy heatmap: {e}", exc_info=True)
         if 'fig_h' in locals() and plt.fignum_exists(fig_h.number): plt.close(fig_h)

    # --- Average Occupancy Bar Chart ---
    try:
        fig_b, ax_b = plt.subplots(figsize=(8, 5))
        if occupancy.size > 0:
            avg_occupancy = np.mean(occupancy, axis=0)
            # Ensure x and y match length
            if len(site_names_ordered) == len(avg_occupancy):
                 # Invert bar order to match inverted heatmap (S0 first)
                 sns.barplot(x=site_names_ordered[::-1], y=avg_occupancy[::-1], ax=ax_b, palette='viridis') # Use STYLE colors?
                 max_avg = np.max(avg_occupancy) if avg_occupancy.size > 0 else 1
                 # Add values, adjusting index for reversed order
                 for i, v in enumerate(avg_occupancy[::-1]):
                     # Using default font sizes controlled by STYLE/rcParams
                     ax_b.text(i, v + 0.01 * max_avg, f"{v:.2f}", ha='center', va='bottom') # Removed explicit fontsize
            else:
                 logger.error(f"Length mismatch for average occupancy plot: {len(site_names_ordered)} sites vs {len(avg_occupancy)} avg values.")
                 ax_b.text(0.5, 0.5, 'Error: Data length mismatch', ha='center', va='center')
        else: ax_b.text(0.5, 0.5, 'No occupancy data', ha='center', va='center')

        ax_b.set_xlabel('Binding Site')
        ax_b.set_ylabel('Average K+ Ion Occupancy')
        # No title
        ax_b.tick_params(axis='x', rotation=45) # Keep rotation
        plt.tight_layout()
        barchart_filename = 'K_Ion_Average_Occupancy.png'
        barchart_path = os.path.join(output_dir, barchart_filename)
        rel_path_b = os.path.relpath(barchart_path, run_dir)
        fig_b.savefig(barchart_path, dpi=150)
        plt.close(fig_b)
        logger.info(f"Saved average occupancy bar chart to {barchart_path}")
        # --- REGISTER PRODUCT (Error Handling Added) ---
        try:
            register_product(db_conn, module_name, "png", "plot", rel_path_b,
                         subcategory="average_occupancy", # Keep consistent subcategory
                         description="Bar chart of average K+ ion occupancy per site.")
            paths['barchart'] = rel_path_b
        except Exception as e_reg:
             logger.error(f"Failed to register average occupancy plot product: {e_reg}")
             # paths['barchart'] remains None

    except Exception as e:
        logger.error(f"Failed to generate average occupancy plot: {e}", exc_info=True)
        if 'fig_b' in locals() and plt.fignum_exists(fig_b.number): plt.close(fig_b)

    return paths['heatmap'], paths['barchart']

# --- Plotting Function: HMM Transitions (NEW) ---
def _plot_hmm_transitions(
    dwell_events_file_path: str, # ion_hmm_dwell_events.csv
    positions_file_path: str,    # ion_positions_g1_centric.csv
    sites_file_path: Optional[str], # binding_site_positions_g1_centric.txt (Optimized)
    ion_stats: Dict[str, Dict[str, float]], # Pre-calculated {ion_idx_str: {'occupancy_pct': ...}}
    output_dir: str,
    run_dir: str,
    db_conn: sqlite3.Connection,
    module_name: str
) -> Optional[str]:
    """Plots HMM idealized vs actual ion trajectories, tiered by occupancy."""
    if not os.path.exists(dwell_events_file_path): logger.error(f"HMM dwell events file not found: {dwell_events_file_path}"); return None
    if not os.path.exists(positions_file_path): logger.error(f"G1-centric positions file not found: {positions_file_path}"); return None

    try:
        df_dwell = pd.read_csv(dwell_events_file_path)
        df_pos = pd.read_csv(positions_file_path)
        time_points = df_pos['Time (ns)'].values
        min_time, max_time = time_points[0], time_points[-1]

        pos_cols = [c for c in df_pos.columns if c.startswith('Ion_') and c.endswith('_Z_G1Centric')]
        if not pos_cols: raise ValueError("No G1-centric position columns found.")
        # Store positions with integer keys
        ions_z_g1 = {int(c.split('_')[1]): df_pos[c].values for c in pos_cols}

        # Get ion IDs present in *either* file to categorize correctly
        ion_ids_dwell = set(df_dwell['ion_idx'].unique()) if not df_dwell.empty else set()
        ion_ids_pos = set(ions_z_g1.keys())
        all_tracked_ion_ids = sorted(list(ion_ids_pos.union(ion_ids_dwell))) # Combine and sort

        # Categorize ions based on occupancy stats
        high_occ_ions = [idx for idx in all_tracked_ion_ids if ion_stats.get(str(idx), {}).get('occupancy_pct', 0) > VIZ_HIGH_OCC_THRESHOLD_PCT]
        medium_occ_ions = [idx for idx in all_tracked_ion_ids if VIZ_MEDIUM_OCC_THRESHOLD_PCT < ion_stats.get(str(idx), {}).get('occupancy_pct', 0) <= VIZ_HIGH_OCC_THRESHOLD_PCT]
        low_occ_ions = [idx for idx in all_tracked_ion_ids if ion_stats.get(str(idx), {}).get('occupancy_pct', 0) <= VIZ_MEDIUM_OCC_THRESHOLD_PCT]
        logger.info(f"Plot tiers: High={len(high_occ_ions)}, Medium={len(medium_occ_ions)}, Low={len(low_occ_ions)}")

    except Exception as e:
        logger.error(f"Error loading HMM dwell/position data for plotting: {e}")
        return None

    # Load optimized site positions
    site_positions = {}
    if sites_file_path and os.path.exists(sites_file_path):
         try:
            with open(sites_file_path, 'r') as f:
                for line in f:
                    if ':' in line and not line.strip().startswith('#'):
                        parts = line.strip().split(':'); site = parts[0].strip()
                        try: site_positions[site] = float(parts[1].strip())
                        except: pass
         except Exception as e: logger.warning(f"Could not load site data for HMM plot: {e}")
    if not site_positions: logger.warning("No site positions loaded for HMM plot background lines."); return None # Need sites for idealized plot

    # --- Plotting ---
    fig, ax = plt.subplots(figsize=(15, 8))
    # Generate colors only for ions that will have lines plotted
    ions_with_lines = high_occ_ions + medium_occ_ions
    if not ions_with_lines: logger.warning("No high or medium occupancy ions to plot lines for."); # Continue for low occ markers maybe
    colors = sns.color_palette("husl", n_colors=len(ions_with_lines)) if ions_with_lines else []
    ion_color_map = {ion_id: color for ion_id, color in zip(ions_with_lines, colors)}
    pastel_color_map = {ion_id: _make_pastel(color) for ion_id, color in ion_color_map.items()}

    idealized_linewidth = STYLE['line_width'] * 1.2
    actual_linewidth_high = STYLE['line_width'] * 0.6
    actual_linewidth_med = STYLE['line_width'] * 0.4
    actual_alpha_high = 0.6
    actual_alpha_med = 0.4
    legend_handles = []
    legend_labels = []

    # Plot High Occupancy Ions (Detailed)
    for ion_id in high_occ_ions:
        color = ion_color_map[ion_id]
        pastel_color = pastel_color_map[ion_id]
        # Plot raw data segments if available
        if ion_id in ions_z_g1:
             z_actual = ions_z_g1[ion_id]
             mask = np.isfinite(z_actual)
             ax.plot(time_points[mask], z_actual[mask], color=pastel_color, linewidth=actual_linewidth_high, alpha=actual_alpha_high, zorder=1)
        # Plot idealized steps
        ion_dwells = df_dwell[df_dwell['ion_idx'] == ion_id]
        step_t, step_z = [], []
        for _, dwell in ion_dwells.iterrows():
            if dwell['site_label'] in site_positions:
                 z_val = site_positions[dwell['site_label']]
                 step_t.extend([dwell['start_time'], dwell['end_time']])
                 step_z.extend([z_val, z_val])
        if step_t:
            line, = ax.step(step_t, step_z, where='post', color=color, linewidth=idealized_linewidth, zorder=2, label=f'Ion {ion_id} (Ideal.)')
            if len(legend_handles) < 10: # Limit legend entries
                 legend_handles.append(line)
                 legend_labels.append(f'Ion {ion_id} ({ion_stats.get(str(ion_id), {}).get("occupancy_pct", 0):.1f}%)')

    # Plot Medium Occupancy Ions (Idealized only)
    for ion_id in medium_occ_ions:
        color = ion_color_map[ion_id]
        ion_dwells = df_dwell[df_dwell['ion_idx'] == ion_id]
        step_t, step_z = [], []
        for _, dwell in ion_dwells.iterrows():
            if dwell['site_label'] in site_positions:
                 z_val = site_positions[dwell['site_label']]
                 step_t.extend([dwell['start_time'], dwell['end_time']])
                 step_z.extend([z_val, z_val])
        if step_t:
             line, = ax.step(step_t, step_z, where='post', color=color, linewidth=idealized_linewidth * 0.8, linestyle='--', zorder=2, label=f'Ion {ion_id} (Ideal.)')
             if len(legend_handles) < 10:
                  legend_handles.append(line)
                  legend_labels.append(f'Ion {ion_id} ({ion_stats.get(str(ion_id), {}).get("occupancy_pct", 0):.1f}%)')


    # Plot Low Occupancy Ions (Markers Only)
    # Need entry/exit events. This requires loading the quality data file potentially, or having computation save entry/exit events separately.
    # Let's assume quality file loading for now, though less efficient.
    entry_exit_times = defaultdict(list)
    # Placeholder: Need to load or get entry/exit times correctly
    # For now, we'll add a placeholder marker to the legend if low_occ_ions exist
    low_occ_marker_added = False
    if low_occ_ions:
         low_occ_marker = Line2D([0], [0], marker='o', color='grey', markersize=4, alpha=0.5, linestyle='None', label=f'Low Occ (<{VIZ_MEDIUM_OCC_THRESHOLD_PCT}%) Entry/Exit')
         if len(legend_handles) < 10:
              legend_handles.append(low_occ_marker)
              legend_labels.append(low_occ_marker.get_label())
              low_occ_marker_added = True

    # Add Site Lines
    site_display_colors = { 'S0': '#FF6347', 'S1': '#4169E1', 'S2': '#2E8B57',
                           'S3': '#BA55D3', 'S4': '#CD853F', 'Cavity': '#708090' }
    z_positions_sorted = sorted(site_positions.items(), key=lambda item: item[1])
    label_x_pos = max_time + (max_time - min_time) * 0.01
    for site, z_pos in z_positions_sorted:
         color = site_display_colors.get(site, 'grey')
         ax.axhline(z_pos, color=color, linestyle='--', linewidth=1, alpha=0.8, zorder=0)
         ax.text(label_x_pos, z_pos, site, va='center', ha='left', color=color, fontsize=STYLE['font_sizes']['annotation'] * 0.9)

    ax.set_xlabel("Time (ns)")
    ax.set_ylabel("Z-Position relative to G1 Cα (Å)")
    ax.tick_params(axis='both', labelsize=STYLE['font_sizes']['tick_label'])
    ax.grid(axis='y', linestyle=STYLE['grid']['linestyle'], alpha=STYLE['grid']['alpha'], color=STYLE['grid']['color'], zorder=0)
    if legend_handles: ax.legend(handles=legend_handles, labels=legend_labels, loc='upper right', fontsize='x-small')

    min_z_plot, max_z_plot = min(site_positions.values()) - 5.0, max(site_positions.values()) + 5.0
    ax.set_ylim(min_z_plot, max_z_plot)
    x_padding = (max_time - min_time) * 0.05
    ax.set_xlim(min_time, max_time + x_padding)
    # No title
    plt.tight_layout()

    plot_filename = 'ion_transitions_hmm.png' # New name
    figure_path = os.path.join(output_dir, plot_filename)
    rel_path = os.path.relpath(figure_path, run_dir)
    try:
        fig.savefig(figure_path, dpi=150)
        plt.close(fig)
        logger.info(f"Saved HMM transitions plot to {figure_path}")
        register_product(db_conn, module_name, "png", "plot", rel_path,
                         subcategory="hmm_transitions_plot", # New subcategory
                         description="Overlay of actual K+ ion Z-positions and HMM-derived idealized site dwells.")
        return rel_path
    except Exception as e:
        logger.error(f"Failed to save/register HMM transitions plot: {e}")
        if plt.fignum_exists(fig.number): plt.close(fig)
        return None


# --- Plotting Function: Quality Metrics (NEW) ---
def _plot_quality_metrics(
    quality_file_path: str, # ion_hmm_quality_data.csv
    ion_stats: Dict[str, Dict[str, float]], # For filtering which ions to plot {ion_idx_str: {'occupancy_pct': ...}}
    output_dir: str,
    run_dir: str,
    db_conn: sqlite3.Connection,
    module_name: str
) -> Optional[str]:
    """Plots HMM fit quality metrics (filter residency, suspicious assignments)."""
    if not os.path.exists(quality_file_path): logger.error(f"HMM quality data file not found: {quality_file_path}"); return None

    try:
        df_quality = pd.read_csv(quality_file_path)
        time_points = df_quality['Time (ns)'].values

        # Identify ions to plot (high and medium occupancy)
        all_ion_ids = []
        susp_cols = {}
        state_cols = {}
        for col in df_quality.columns:
             if col.startswith('Ion_') and col.endswith('_SuspiciousFlag'):
                 # Extract index, ensuring it's treated as int for consistency
                 try: idx = int(col.split('_')[1]); all_ion_ids.append(idx); susp_cols[idx] = col
                 except (ValueError, IndexError): logger.warning(f"Could not parse ion index from column: {col}"); continue
             if col.startswith('Ion_') and col.endswith('_HMM_State'):
                 try: idx = int(col.split('_')[1]); state_cols[idx] = col
                 except (ValueError, IndexError): continue

        # Ensure we only use ions present in ion_stats (using string keys as calculated before)
        ions_to_plot = sorted([
            idx for idx in all_ion_ids if
            ion_stats.get(str(idx), {}).get('occupancy_pct', 0) > VIZ_MEDIUM_OCC_THRESHOLD_PCT
        ])

        if not ions_to_plot: logger.info("No ions met threshold for quality plot."); return None
        n_ions = len(ions_to_plot)
        logger.info(f"Generating quality plot for {n_ions} ions.")

    except Exception as e:
        logger.error(f"Error loading HMM quality data: {e}")
        return None

    # --- Plotting ---
    fig, axes = plt.subplots(n_ions, 1, figsize=(15, n_ions * 1.7), sharex=True, squeeze=False)
    axes = axes.flatten() # Ensure axes is always iterable

    colors = sns.color_palette("husl", n_colors=n_ions)
    ion_color_map = {ion_id: color for ion_id, color in zip(ions_to_plot, colors)}

    for i, ion_id in enumerate(ions_to_plot):
        ax = axes[i]
        color = ion_color_map.get(ion_id, 'grey') # Use .get with fallback

        susp_flag_col = susp_cols.get(ion_id)
        hmm_state_col = state_cols.get(ion_id)

        if not susp_flag_col or not hmm_state_col or susp_flag_col not in df_quality or hmm_state_col not in df_quality:
             logger.warning(f"Missing quality/state columns for ion {ion_id} in quality plot.")
             ax.text(0.5, 0.5, f"Data missing for Ion {ion_id}", ha='center', va='center', transform=ax.transAxes)
             continue # Skip plotting this ion

        suspicious_flags = df_quality[susp_flag_col].values.astype(bool)
        hmm_states = df_quality[hmm_state_col].values

        # Plot presence/absence in filter (derived from HMM state != 'Outside')
        in_filter_mask = (hmm_states != 'Outside') & (hmm_states != 'Unknown') # Check against known non-filter states
        presence = np.zeros_like(time_points)
        presence[in_filter_mask] = 1.0 # Use 0 to 1 scale

        # Plot filter presence base (0 to 0.8)
        ax.fill_between(time_points, 0, presence * 0.8, color=color, alpha=0.3, label='In Filter', step='post')

        # Overlay suspicious assignments (0.8 to 1.0 where suspicious and in filter)
        suspicious_mask = suspicious_flags & in_filter_mask
        suspicious_height = np.zeros_like(time_points)
        suspicious_height[suspicious_mask] = 0.2 # Height of the overlay
        ax.fill_between(time_points, presence * 0.8, presence * 0.8 + suspicious_height, color=color, alpha=0.6, label='Poor Fit', step='post', hatch='///')

        # Configure subplot
        ax.set_ylim(-0.05, 1.05)
        ax.grid(True, ls=':', alpha=0.4)
        ax.set_yticks([0, 0.4, 0.9]) # Adjusted ticks slightly
        ax.set_yticklabels(['Outside', 'In Filter\n(Good Fit)', 'In Filter\n(Poor Fit)'])
        ax.tick_params(axis='y', labelsize=STYLE['font_sizes']['tick_label']*0.9)

        if i == n_ions - 1: ax.set_xlabel('Time (ns)')
        else: ax.tick_params(axis='x', bottom=False, labelbottom=False) # Hide x-ticks for upper plots

        occ_pct = ion_stats.get(str(ion_id), {}).get('occupancy_pct', 0)
        ax.set_ylabel(f"Ion {ion_id}\n({occ_pct:.1f}%)", color=color, fontweight='bold', fontsize=STYLE['font_sizes']['axis_label']*0.9)
        ax.spines['left'].set_color(color); ax.spines['left'].set_linewidth(1.5)
        ax.tick_params(axis='y', colors=color)
        # Hide other spines for clarity
        for spine in ['right', 'top', 'bottom']: ax.spines[spine].set_visible(False)


    # No title
    plt.tight_layout()
    plt.subplots_adjust(hspace=0.15) # Adjust space between panels

    plot_filename = 'ion_quality_metrics.png' # New name
    figure_path = os.path.join(output_dir, plot_filename)
    rel_path = os.path.relpath(figure_path, run_dir)
    try:
        fig.savefig(figure_path, dpi=150)
        plt.close(fig)
        logger.info(f"Saved HMM quality metrics plot to {figure_path}")
        register_product(db_conn, module_name, "png", "plot", rel_path,
                         subcategory="quality_metrics_plot", # New subcategory
                         description="HMM quality metrics (filter residency, suspicious assignments).")
        return rel_path
    except Exception as e:
        logger.error(f"Failed to save/register HMM quality metrics plot: {e}")
        if plt.fignum_exists(fig.number): plt.close(fig)
        return None


# --- Main Visualization Orchestrator ---
def generate_ion_plots(
    run_dir: str,
    db_conn: sqlite3.Connection
) -> Dict[str, Any]:
    """
    Generates all standard plots for the ion analysis module using HMM results.
    Retrieves necessary data file paths from the database.

    Args:
        run_dir: Path to the specific run directory.
        db_conn: Active database connection.

    Returns:
        Dictionary containing status and paths to generated plots.
    """
    module_name = "ion_analysis_visualization"
    start_time = time.time()
    register_module(db_conn, module_name, status='running')
    logger.info(f"--- Starting Ion Analysis Visualization (HMM) for {run_dir} ---")

    results = {'status': 'failed', 'plots': {}}
    output_dir = os.path.join(run_dir, "ion_analysis")
    os.makedirs(output_dir, exist_ok=True)

    # --- Retrieve necessary file paths from DB ---
    # Use NEW subcategories defined during HMM computation registration
    pos_g1_rel = get_product_path(db_conn, 'csv', 'data', 'ion_positions_g1_centric', 'ion_analysis')
    sites_rel = get_product_path(db_conn, 'txt', 'definition', 'binding_sites_definition', 'ion_analysis') # Optimized sites
    occ_frame_rel = get_product_path(db_conn, 'csv', 'data', 'ion_occupancy_per_frame', 'ion_analysis')
    hmm_dwell_rel = get_product_path(db_conn, 'csv', 'data', 'ion_hmm_dwell_events', 'ion_analysis') # New dwell events file
    hmm_quality_rel = get_product_path(db_conn, 'csv', 'data', 'ion_hmm_quality_data', 'ion_analysis') # New quality file
    presence_rel = get_product_path(db_conn, 'csv', 'data', 'ion_filter_presence', 'ion_analysis') # Needed for occupancy stats workaround
    site_opt_plot_rel = get_product_path(db_conn, 'png', 'plot', 'site_optimization_plot', 'ion_analysis') # Site opt plot (registered by structure.py)

    # Convert relative paths to absolute
    pos_g1_abs = os.path.join(run_dir, pos_g1_rel) if pos_g1_rel else None
    sites_abs = os.path.join(run_dir, sites_rel) if sites_rel else None
    occ_frame_abs = os.path.join(run_dir, occ_frame_rel) if occ_frame_rel else None
    hmm_dwell_abs = os.path.join(run_dir, hmm_dwell_rel) if hmm_dwell_rel else None
    hmm_quality_abs = os.path.join(run_dir, hmm_quality_rel) if hmm_quality_rel else None
    presence_abs = os.path.join(run_dir, presence_rel) if presence_rel else None


    # --- Load/Calculate Occupancy Stats (needed for tiered plotting) ---
    ion_stats_occ = {} # Use string ion index as key
    if presence_abs and os.path.exists(presence_abs):
        logger.info("Calculating per-ion occupancy from presence file for visualization tiers...")
        try:
            df_pres = pd.read_csv(presence_abs)
            total_frames = len(df_pres)
            if total_frames > 0:
                 for col in df_pres.columns:
                     if col.startswith('Ion_') and col.endswith('_InFilter'):
                          try:
                               ion_idx_str = col.split('_')[1]
                               valid_count = df_pres[col].sum() # Sum of True values
                               occ_pct = (valid_count / total_frames) * 100
                               ion_stats_occ[ion_idx_str] = {'occupancy_pct': occ_pct}
                          except (IndexError, ValueError):
                               logger.warning(f"Could not parse ion index from presence column: {col}")
            else: logger.warning("Presence file is empty.")
        except Exception as e_occ:
            logger.error(f"Failed to calculate ion occupancy from presence file: {e_occ}")
    else:
        logger.error("Ion presence file path not found or file doesn't exist. Cannot determine viz tiers.")
        # Continue, but tiered plotting will not work correctly.

    # --- Generate Plots ---
    plots_generated = 0
    plots_failed = 0

    # 1. Binding Site Schematic (Using optimized sites file)
    if sites_abs:
        logger.info("Generating binding site schematic...")
        schematic_path = _plot_binding_site_schematic(sites_abs, output_dir, run_dir, db_conn, module_name)
        if schematic_path: plots_generated += 1; results['plots']['binding_sites_visualization'] = schematic_path
        else: plots_failed += 1
    else: logger.warning("Skipping binding site schematic: Definition file path not found in DB.")

    # Add site optimization plot path if it exists (registered by structure.py)
    if site_opt_plot_rel:
         results['plots']['site_optimization_plot'] = site_opt_plot_rel # Key should match plots_dict.json

    # 2. Ion Positions & Density (Unchanged logic, uses pos_g1_abs, sites_abs)
    if pos_g1_abs:
        logger.info("Generating ion position/density plot...")
        combined_plot_path = _plot_ion_positions_density(pos_g1_abs, sites_abs, output_dir, run_dir, db_conn, module_name)
        if combined_plot_path: plots_generated += 1; results['plots']['combined_plot'] = combined_plot_path
        else: plots_failed += 1
    else: logger.warning("Skipping ion position/density plot: Position file path not found in DB.")

    # 3. Occupancy Heatmap & Bar Chart (Unchanged logic, uses occ_frame_abs)
    if occ_frame_abs:
        logger.info("Generating occupancy heatmap and bar chart...")
        heatmap_path, barchart_path = _plot_occupancy_maps(occ_frame_abs, output_dir, run_dir, db_conn, module_name)
        if heatmap_path: plots_generated += 1; results['plots']['occupancy_heatmap'] = heatmap_path
        else: plots_failed += 1
        if barchart_path: plots_generated += 1; results['plots']['average_occupancy'] = barchart_path
        else: plots_failed += 1
    else: logger.warning("Skipping occupancy plots: Occupancy per frame file path not found in DB.")

    # 4. HMM Transitions Plot (NEW)
    if hmm_dwell_abs and pos_g1_abs:
        logger.info("Generating HMM transitions plot...")
        hmm_trans_path = _plot_hmm_transitions(hmm_dwell_abs, pos_g1_abs, sites_abs, ion_stats_occ, output_dir, run_dir, db_conn, module_name)
        if hmm_trans_path: plots_generated += 1; results['plots']['hmm_transitions_plot'] = hmm_trans_path # New key
        else: plots_failed += 1
    else: logger.warning("Skipping HMM transitions plot: HMM dwell or position file path not found in DB.")

    # 5. Quality Metrics Plot (NEW - Not displayed in main report)
    if hmm_quality_abs:
        logger.info("Generating HMM quality metrics plot...")
        quality_path = _plot_quality_metrics(hmm_quality_abs, ion_stats_occ, output_dir, run_dir, db_conn, module_name)
        if quality_path: plots_generated += 1; results['plots']['quality_metrics_plot'] = quality_path # New key
        else: plots_failed += 1
    else: logger.warning("Skipping quality metrics plot: HMM quality data file path not found in DB.")


    # --- Finalize ---
    exec_time = time.time() - start_time
    final_status = 'success' if plots_failed == 0 and plots_generated > 0 else ('failed' if plots_failed > 0 else 'skipped')
    error_msg = f"{plots_failed} plot(s) failed to generate." if plots_failed > 0 else None

    update_module_status(db_conn, module_name, final_status, execution_time=exec_time, error_message=error_msg)
    logger.info(f"--- Ion Analysis Visualization (HMM) finished in {exec_time:.2f} seconds (Status: {final_status}) ---")
    results['status'] = final_status
    return results